const crypto = require('crypto');
const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand } = require("@aws-sdk/lib-dynamodb");

// ============= AUTH UTILS =============
function verifyJWT(token) {
  try {
    const [header, payload, signature] = token.split('.');
    
    const expectedSignature = crypto
      .createHmac('sha256', process.env.JWT_SECRET || 'default-secret-key')
      .update(`${header}.${payload}`)
      .digest('base64url');
    
    if (signature !== expectedSignature) {
      return { valid: false, error: 'Invalid signature' };
    }
    
    const decodedPayload = JSON.parse(Buffer.from(payload, 'base64url').toString());
    
    if (decodedPayload.exp < Math.floor(Date.now() / 1000)) {
      return { valid: false, error: 'Token expired' };
    }
    
    return { valid: true, payload: decodedPayload };
  } catch (error) {
    return { valid: false, error: 'Invalid token format' };
  }
}

// ============= RESPONSE HELPERS =============
function successResponse(data) {
  return {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(data),
  };
}

function errorResponse(statusCode, message) {
  return {
    statusCode,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ error: message }),
  };
}

// ============= WHEEL UTILS =============
/**
 * Генерация уникального промокода на основе типа приза
 * @param {string} prizeType - тип приза (discount_10, discount_20, points, delivery, free_item, jackpot)
 * @returns {string} - промокод
 */
function generatePromoCode(prizeType) {
  const prefix = {
    'discount_10': 'WISH10',
    'discount_20': 'RAND20',
    'jackpot': 'JACKPOT40',
    'free_item': 'FREE',
    'delivery': 'SHIP',
    'points': 'PTS'
  }[prizeType] || 'PRIZE';
  
  const random = crypto.randomBytes(2).toString('hex').toUpperCase();
  return `${prefix}-${random}`;
}

/**
 * Получение списка доступных призов на основе текущего количества спинов
 * Прогрессивная система: больше спинов = доступ к лучшим призам
 * @param {number} currentSpins - текущее количество спинов у пользователя
 * @returns {Array<string>} - массив доступных типов призов
 */
function getAvailablePrizes(currentSpins) {
  // Защита от невалидных значений
  if (!currentSpins || currentSpins < 1 || typeof currentSpins !== 'number') {
    // Если спинов нет или значение невалидно, возвращаем минимальный уровень
    return ['discount_10'];
  }
  
  // Клампинг к целому числу и разумному максимуму
  const spins = Math.floor(Math.min(Math.max(currentSpins, 1), 9999));
  
  // Уровень 1: 1 спин
  if (spins === 1) {
    return ['discount_10'];
  }
  
  // Уровень 2: 2 спина
  if (spins === 2) {
    return ['discount_10', 'discount_20'];
  }
  
  // Уровень 3: 3 спина
  if (spins === 3) {
    return ['discount_10', 'discount_20', 'points'];
  }
  
  // Уровень 4: 4 спина
  if (spins === 4) {
    return ['discount_10', 'discount_20', 'points', 'delivery'];
  }
  
  // Уровень 5: 5 спинов
  if (spins === 5) {
    return ['discount_10', 'discount_20', 'points', 'delivery', 'free_item'];
  }
  
  // Уровень 6: 6+ спинов - доступны ВСЕ призы, включая джекпот
  return ['discount_10', 'discount_20', 'points', 'delivery', 'free_item', 'jackpot'];
}

/**
 * Определение приза по случайному числу с учетом доступных призов
 * Оригинальные веса призов:
 * - discount_10: 30%
 * - discount_20: 25%
 * - points: 20%
 * - delivery: 15%
 * - free_item: 8%
 * - jackpot: 2%
 * 
 * Функция автоматически ренормализует вероятности на основе доступных призов
 * @param {number} randomValue - случайное число (0-100)
 * @param {number} currentSpins - текущее количество спинов у пользователя
 * @returns {string} - тип выигранного приза
 */
function determinePrize(randomValue, currentSpins) {
  // Получаем список доступных призов на основе уровня пользователя
  const availablePrizes = getAvailablePrizes(currentSpins);
  
  // Оригинальные веса призов
  const prizeWeights = {
    'discount_10': 30,
    'discount_20': 25,
    'points': 20,
    'delivery': 15,
    'free_item': 8,
    'jackpot': 2
  };
  
  // Фильтруем только доступные призы и их веса
  const availableWeights = {};
  let totalWeight = 0;
  
  for (const prize of availablePrizes) {
    availableWeights[prize] = prizeWeights[prize];
    totalWeight += prizeWeights[prize];
  }
  
  // Ренормализуем случайное значение под общий вес доступных призов
  const normalizedRandom = (randomValue / 100) * totalWeight;
  
  // Определяем приз на основе ренормализованных вероятностей
  let cumulative = 0;
  for (const prize of availablePrizes) {
    cumulative += availableWeights[prize];
    if (normalizedRandom < cumulative) {
      return prize;
    }
  }
  
  // Fallback на последний доступный приз (не должно произойти)
  return availablePrizes[availablePrizes.length - 1];
}

/**
 * Расчет даты истечения приза
 * @param {string} prizeType - тип приза
 * @returns {string} - дата в формате ISO
 */
function calculateExpiryDate(prizeType) {
  const now = new Date();
  const daysToAdd = {
    'discount_10': 14,    // 14 дней
    'discount_20': 21,    // 21 день
    'points': 365,        // 12 месяцев
    'delivery': 60,       // 60 дней
    'free_item': 10,      // 10 дней
    'jackpot': 2          // 48 часов
  }[prizeType] || 7;
  
  now.setDate(now.getDate() + daysToAdd);
  return now.toISOString();
}

/**
 * Генерация криптографически безопасного случайного числа (0-100)
 * @returns {number} - случайное число от 0 до 100
 */
function getSecureRandom() {
  const buffer = crypto.randomBytes(4);
  const value = buffer.readUInt32BE(0);
  return (value / 0xFFFFFFFF) * 100;
}

/**
 * Генерация уникального ID для приза или записи истории
 * @returns {string} - уникальный ID
 */
function generatePrizeId() {
  return Date.now().toString(36) + crypto.randomBytes(4).toString('hex');
}

/**
 * Получение названия приза для отображения
 * @param {string} prizeType - тип приза
 * @returns {string} - название для отображения
 */
function getPrizeDisplayName(prizeType) {
  const names = {
    'discount_10': 'Скидка 10% на весь заказ',
    'discount_20': 'Скидка 20% на товар',
    'points': '+200 баллов',
    'delivery': 'Бесплатная доставка',
    'free_item': 'Бесплатный товар',
    'jackpot': 'ДЖЕКПОТ! -40% на весь заказ'
  };
  return names[prizeType] || prizeType;
}

/**
 * Расчет количества спинов на основе суммы заказа
 * Формула: 1 спин за каждые 1000₽
 * @param {number} orderTotal - общая сумма заказа
 * @returns {number} - количество заработанных спинов
 */
function calculateSpinsFromOrder(orderTotal) {
  if (!orderTotal || orderTotal < 1000) {
    return 0;
  }
  return Math.floor(orderTotal / 1000);
}

// ============= DATABASE CLIENT =============
const client = new DynamoDBClient({
  region: "ru-central1",
  endpoint: process.env.YDB_ENDPOINT,
  credentials: {
    accessKeyId: process.env.YDB_ACCESS_KEY_ID,
    secretAccessKey: process.env.YDB_SECRET_KEY,
  },
});

const docClient = DynamoDBDocumentClient.from(client, {
  marshallOptions: {
    removeUndefinedValues: true,
    convertEmptyValues: false,
  },
  unmarshallOptions: {
    wrapNumbers: false,
  },
});

// ============= MAIN HANDLER =============
exports.handler = async (event) => {
  try {
    console.log('=== SPIN WHEEL REQUEST ===');
    console.log('Headers:', JSON.stringify(event.headers, null, 2));

    // 1. Получить и верифицировать токен
    const authHeader = event.headers?.Authorization || event.headers?.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return errorResponse(401, 'Необходима авторизация');
    }

    const token = authHeader.substring(7);
    const verification = verifyJWT(token);

    if (!verification.valid) {
      return errorResponse(401, 'Неверный токен');
    }

    const userId = verification.payload.userId;
    const userEmail = verification.payload.email;
    console.log('User ID:', userId, 'Email:', userEmail);

    // Проверка наличия email в токене
    if (!userEmail) {
      console.error('❌ Email отсутствует в JWT payload. Токен устарел или поврежден.');
      return errorResponse(401, 'Ваша сессия устарела. Пожалуйста, выйдите и войдите заново.');
    }

    // 2. Получить пользователя и проверить спины
    const userResult = await docClient.send(new GetCommand({
      TableName: "users",
      Key: { email: userEmail }
    }));

    const user = userResult.Item;
    if (!user) {
      return errorResponse(404, 'Пользователь не найден');
    }

    const currentSpins = user.spins || 0;
    const totalSpinsEarned = user.totalSpinsEarned || 0;
    console.log('Current spins:', currentSpins, 'Total earned:', totalSpinsEarned);

    if (currentSpins < 1) {
      return errorResponse(400, 'Недостаточно спинов');
    }

    // 3. Получить корзину (ИЗМЕНЕНО: вместо вишлиста)
    const cartResult = await docClient.send(new GetCommand({
      TableName: "carts",
      Key: { userId }
    }));

    const cartItems = cartResult.Item?.items || [];
    console.log('Cart items count:', cartItems.length);

    if (cartItems.length === 0) {
      return errorResponse(400, 'Добавьте товары в корзину для участия в рулетке');
    }

    // 4. Генерация приза с учетом прогрессивной системы
    const randomValue = getSecureRandom();
    const prizeType = determinePrize(randomValue, currentSpins);
    const promoCode = generatePromoCode(prizeType);
    const expiresAt = calculateExpiryDate(prizeType);
    const prizeId = generatePrizeId();

    console.log('Prize generated:', { prizeType, randomValue, currentSpins });

    // 5. Подготовка данных приза
    let prize = {
      id: prizeId,
      userId,
      prizeType,
      promoCode,
      expiresAt,
      used: false,
      createdAt: new Date().toISOString()
    };

    // Дополнительные данные в зависимости от типа приза
    if (prizeType === 'discount_10') {
      prize.discountValue = 10;
    } 
    else if (prizeType === 'discount_20') {
      // ИЗМЕНЕНО: выбираем из корзины вместо вишлиста
      const randomIndex = Math.floor(Math.random() * cartItems.length);
      const randomCartItem = cartItems[randomIndex];

      const productResult = await docClient.send(new GetCommand({
        TableName: "products",
        Key: { id: randomCartItem.productId }
      }));

      if (productResult.Item) {
        prize.productId = randomCartItem.productId;
        prize.productName = productResult.Item.name;
        prize.productImage = productResult.Item.image;
      }
      prize.discountValue = 20;
    } 
    else if (prizeType === 'points') {
      prize.pointsAmount = 200;
      
      await docClient.send(new UpdateCommand({
        TableName: "users",
        Key: { email: userEmail },
        UpdateExpression: "SET loyaltyPoints = if_not_exists(loyaltyPoints, :zero) + :points",
        ExpressionAttributeValues: {
          ":points": 200,
          ":zero": 0
        }
      }));
    } 
    else if (prizeType === 'free_item') {
      // ИЗМЕНЕНО: ищем дешевый товар в корзине вместо вишлиста
      const itemsToCheck = cartItems.slice(0, 10);
      
      const products = await Promise.all(
        itemsToCheck.map(item =>
          docClient.send(new GetCommand({
            TableName: "products",
            Key: { id: item.productId }
          })).then(res => res.Item).catch(() => null)
        )
      );

      const validProducts = products.filter(p => p && p.price);
      if (validProducts.length > 0) {
        const cheapest = validProducts.reduce((min, p) =>
          (!min || p.price < min.price) ? p : min
        );

        prize.productId = cheapest.id;
        prize.productName = cheapest.name;
        prize.productImage = cheapest.image;
      }
    } 
    else if (prizeType === 'jackpot') {
      prize.discountValue = 40;
      // ИЗМЕНЕНО: джекпот на все товары в корзине
      prize.appliesToAllCart = true;
      prize.cartSnapshot = cartItems.slice(0, 50).map(item => item.productId);
    }
    else if (prizeType === 'delivery') {
      // Бесплатная доставка
    }

    // 6. Сохранить приз в таблицу wheelPrizes
    try {
      const prizeItem = {
        id: prizeId,
        userId: userId,
        prizeType: prizeType,
        promoCode: promoCode,
        expiresAt: expiresAt,
        createdAt: new Date().toISOString(),
        used: false
      };
      
      // Добавляем опциональные поля только если они есть
      if (prize.discountValue !== undefined) prizeItem.discountValue = prize.discountValue;
      if (prize.pointsAmount !== undefined) prizeItem.pointsAmount = prize.pointsAmount;
      if (prize.productId !== undefined) prizeItem.productId = prize.productId;
      if (prize.productName !== undefined) prizeItem.productName = prize.productName;
      if (prize.productImage !== undefined) prizeItem.productImage = prize.productImage;
      if (prize.appliesToAllCart !== undefined) prizeItem.appliesToAllCart = prize.appliesToAllCart;
      if (prize.cartSnapshot !== undefined) prizeItem.cartSnapshot = prize.cartSnapshot;
      
      await docClient.send(new PutCommand({
        TableName: "wheelPrizes",
        Item: prizeItem
      }));
      console.log('✅ Prize saved to wheelPrizes:', prizeId);
    } catch (err) {
      console.warn('⚠️ Warning saving to wheelPrizes:', err.message);
    }
    // 7. Сохранить в историю wheelHistory
    try {
      const historyId = generatePrizeId();
      const historyItem = {
        id: historyId,
        userId: userId,
        prizeType: prizeType,
        prizeValue: getPrizeDisplayName(prizeType),
        createdAt: new Date().toISOString()
      };
      if (prize.productName) historyItem.productName = prize.productName;
      if (prize.discountValue) historyItem.discountAmount = prize.discountValue;
      await docClient.send(new PutCommand({
        TableName: "wheelHistory",
        Item: historyItem
      }));
      console.log('✅ Prize saved to wheelHistory:', historyId);
    } catch (err) {
      console.error('❌ Error saving to wheelHistory:', err);
    }

    // 8. Обновить счетчики
    await docClient.send(new UpdateCommand({
      TableName: "users",
      Key: { email: userEmail },
      UpdateExpression: "SET spins = spins - :one, totalWheelSpins = if_not_exists(totalWheelSpins, :zero) + :one",
      ExpressionAttributeValues: {
        ":one": 1,
        ":zero": 0
      }
    }));

    console.log('Prize awarded successfully:', prizeId);

    return successResponse({
      success: true,
      prize
    });

  } catch (error) {
    console.error("Error spinning wheel:", error);
    return errorResponse(500, error.message || 'Ошибка при вращении рулетки');
  }
};