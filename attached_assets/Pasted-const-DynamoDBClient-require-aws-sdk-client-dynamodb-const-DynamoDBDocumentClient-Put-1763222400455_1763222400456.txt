const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, PutCommand, ScanCommand, UpdateCommand, GetCommand } = require("@aws-sdk/lib-dynamodb");
const https = require('https');

const client = new DynamoDBClient({
  region: "ru-central1",
  endpoint: process.env.YDB_ENDPOINT,
  credentials: {
    accessKeyId: process.env.YDB_ACCESS_KEY_ID,
    secretAccessKey: process.env.YDB_SECRET_KEY,
  },
});

const docClient = DynamoDBDocumentClient.from(client, {
  marshallOptions: {
    removeUndefinedValues: true,
    convertEmptyValues: false,
  },
  unmarshallOptions: {
    wrapNumbers: false,
  },
});

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ Telegram (–≤—Å—Ç—Ä–æ–µ–Ω–æ –≤ —Ñ—É–Ω–∫—Ü–∏—é create-order)
 */
async function sendTelegramNotification(orderData) {
  const botToken = process.env.TELEGRAM_BOT_TOKEN;
  const chatId = process.env.TELEGRAM_CHAT_ID;

  if (!botToken || !chatId) {
    console.warn('Telegram credentials not configured, skipping notification');
    return;
  }

  const {
    id,
    customerName,
    customerEmail,
    customerPhone,
    items,
    total,
    subtotal,
    discount,
    promoCode,
    shippingAddress,
    createdAt,
    deliveryService,
    deliveryType,
    cdekDeliveryCost,
    deliveryCost,
    deliveryPointName,
  } = orderData;

  const orderNumber = id.substring(0, 8).toUpperCase();
  const orderDate = new Date(createdAt).toLocaleString('ru-RU', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });

  let message = `üõçÔ∏è <b>–ù–æ–≤—ã–π –∑–∞–∫–∞–∑ #${orderNumber}</b>\n\n`;
  message += `üë§ <b>–ö–ª–∏–µ–Ω—Ç:</b> ${customerName}\n`;
  message += `üìß <b>Email:</b> ${customerEmail}\n`;
  message += `üì± <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> ${customerPhone}\n\n`;
  message += `üõí <b>–¢–æ–≤–∞—Ä—ã:</b>\n`;
  
  items.forEach(item => {
    message += `  ‚Ä¢ ${item.name} x${item.quantity} - ${item.price * item.quantity}‚ÇΩ\n`;
  });
  
  if (promoCode) {
    message += `\nüí∏ <b>–ü—Ä–æ–º–æ–∫–æ–¥:</b> ${promoCode} (-${discount}‚ÇΩ)\n`;
    message += `üìä <b>–ü–æ–¥—ã—Ç–æ–≥:</b> ${subtotal}‚ÇΩ\n`;
  }
  
  message += `\nüí∞ <b>–ò—Ç–æ–≥–æ:</b> ${total}‚ÇΩ\n\n`;
  
  // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–æ—Å—Ç–∞–≤–∫–µ
  if (deliveryService === 'CDEK') {
    message += `üöö <b>–î–æ—Å—Ç–∞–≤–∫–∞:</b> –°–î–≠–ö`;
    if (deliveryType === 'PICKUP') {
      message += ` (–ü—É–Ω–∫—Ç –≤—ã–¥–∞—á–∏)\n`;
      if (deliveryPointName) {
        message += `üìç <b>–ü—É–Ω–∫—Ç –≤—ã–¥–∞—á–∏:</b> ${deliveryPointName}\n`;
      }
    } else if (deliveryType === 'DOOR') {
      message += ` (–î–æ –¥–≤–µ—Ä–∏)\n`;
    } else {
      message += `\n`;
    }
    if (cdekDeliveryCost) {
      message += `üíµ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏:</b> ${cdekDeliveryCost}‚ÇΩ\n`;
    }
  } else if (deliveryService === 'POST') {
    message += `üöö <b>–î–æ—Å—Ç–∞–≤–∫–∞:</b> –ü–æ—á—Ç–∞ –†–æ—Å—Å–∏–∏\n`;
    if (deliveryCost) {
      message += `üíµ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏:</b> ${deliveryCost}‚ÇΩ\n`;
    }
  }
  
  message += `\nüì¶ <b>–ê–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:</b>\n${shippingAddress}\n\n`;
  message += `‚è∞ ${orderDate}`;

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
  const payload = JSON.stringify({
    chat_id: chatId,
    text: message,
    parse_mode: 'HTML',
  });

  return new Promise((resolve, reject) => {
    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(payload),
      },
    };

    const req = https.request(url, options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        if (res.statusCode === 200) {
          console.log('Telegram notification sent successfully');
          resolve(JSON.parse(data));
        } else {
          console.error(`Telegram API error: ${res.statusCode} - ${data}`);
          reject(new Error(`Telegram API error: ${res.statusCode}`));
        }
      });
    });

    req.on('error', (error) => {
      console.error('Error sending Telegram notification:', error);
      reject(error);
    });

    req.write(payload);
    req.end();
  });
}

exports.handler = async (event) => {
  try {
    const orderData = JSON.parse(event.body || '{}');
    
    if (!orderData.userId || !orderData.items || !orderData.total) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ error: "Missing required order fields" }),
      };
    }

    const id = generateId();
    const order = {
      ...orderData,
      id,
      createdAt: new Date().toISOString(),
      status: 'pending',
      
      // –î–∞–Ω–Ω—ã–µ –¥–æ—Å—Ç–∞–≤–∫–∏ (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –°–î–≠–ö –∏ –¥—Ä—É–≥–∏—Ö —Å–ª—É–∂–±)
      deliveryService: orderData.deliveryService || null,
      deliveryType: orderData.deliveryType || null,
      deliveryStatus: orderData.deliveryStatus || (orderData.deliveryService ? 'PENDING' : null),
      
      // –ê–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ (–¥–ª—è –∫—É—Ä—å–µ—Ä—Å–∫–æ–π –¥–æ—Å—Ç–∞–≤–∫–∏)
      deliveryAddress: orderData.deliveryAddress || null,
      deliveryCity: orderData.deliveryCity || null,
      deliveryPostalCode: orderData.deliveryPostalCode || null,
      deliveryRecipientName: orderData.deliveryRecipientName || null,
      deliveryRecipientPhone: orderData.deliveryRecipientPhone || null,
      
      // –î–∞–Ω–Ω—ã–µ –ø—É–Ω–∫—Ç–∞ –≤—ã–¥–∞—á–∏ (–¥–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ –ü–í–ó)
      deliveryPointCode: orderData.deliveryPointCode || null,
      deliveryPointName: orderData.deliveryPointName || null,
      deliveryPointAddress: orderData.deliveryPointAddress || null,
      
      // –î–∞–Ω–Ω—ã–µ –°–î–≠–ö
      cdekOrderUuid: orderData.cdekOrderUuid || null,
      cdekOrderNumber: orderData.cdekOrderNumber || null,
      cdekTrackNumber: orderData.cdekTrackNumber || null,
      cdekTariffCode: orderData.cdekTariffCode || null,
      cdekDeliveryCost: orderData.cdekDeliveryCost || null,
      
      // –†–∞—Å—á–µ—Ç–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
      estimatedDeliveryDays: orderData.estimatedDeliveryDays || null,
      deliveryCalculatedAt: orderData.deliveryCalculatedAt || null,
    };

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–∫–∞–∑ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    await docClient.send(new PutCommand({
      TableName: "orders",
      Item: order,
    }));

    // ‚≠ê –ù–û–í–´–ô –ö–û–î: –£–º–µ–Ω—å—à–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ —Å–∫–ª–∞–¥–µ
    for (const item of orderData.items) {
      try {
        // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ç–æ–≤–∞—Ä –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        const productResult = await docClient.send(new GetCommand({
          TableName: "products",
          Key: { id: item.productId }
        }));

        if (productResult.Item && productResult.Item.stock !== undefined) {
          // –£–º–µ–Ω—å—à–∞–µ–º stock –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑ –∑–∞–∫–∞–∑–∞
          const newStock = Math.max(0, productResult.Item.stock - item.quantity);
          
          await docClient.send(new UpdateCommand({
            TableName: "products",
            Key: { id: item.productId },
            UpdateExpression: "SET stock = :newStock",
            ExpressionAttributeValues: {
              ":newStock": newStock
            }
          }));
          
          console.log(`Updated stock for product ${item.productId}: ${productResult.Item.stock} -> ${newStock}`);
        } else {
          console.warn(`Product ${item.productId} not found or has no stock field`);
        }
      } catch (error) {
        console.error(`Error updating stock for product ${item.productId}:`, error);
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å stock –æ–¥–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞
      }
    }

    // –ù–∞—á–∏—Å–ª–∏—Ç—å —Å–ø–∏–Ω—ã –∑–∞ –∑–∞–∫–∞–∑ (1 —Å–ø–∏–Ω –∑–∞ –∫–∞–∂–¥—ã–µ 1000‚ÇΩ)
    const spinsToAdd = Math.floor(orderData.total / 1000);
    let actualSpinsAdded = 0;

    if (spinsToAdd > 0 && orderData.userEmail) {
      console.log(`Adding ${spinsToAdd} spins for order total ${orderData.total}‚ÇΩ`);
      
      try {
        // –ü–æ–ª—É—á–∏—Ç—å email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const userResult = await docClient.send(new GetCommand({
          TableName: "users",
          Key: { email: orderData.userEmail }
        }));

        if (userResult.Item) {
          // –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
          await docClient.send(new UpdateCommand({
            TableName: "users",
            Key: { email: orderData.userEmail },
            UpdateExpression: "SET spins = if_not_exists(spins, :zero) + :spinsToAdd, totalSpinsEarned = if_not_exists(totalSpinsEarned, :zero) + :spinsToAdd",
            ExpressionAttributeValues: {
              ":spinsToAdd": spinsToAdd,
              ":zero": 0
            }
          }));
          
          actualSpinsAdded = spinsToAdd;
          console.log(`Successfully added ${spinsToAdd} spins to user ${orderData.userEmail}`);
        } else {
          console.warn(`User not found: ${orderData.userEmail}`);
        }
      } catch (error) {
        console.error("Error adding spins:", error);
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞–∫–∞–∑–∞, –µ—Å–ª–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–µ —Å–ø–∏–Ω–æ–≤ –Ω–µ —É–¥–∞–ª–æ—Å—å
      }
    }

    // –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –ø—Ä–æ–º–æ–∫–æ–¥ —Ä—É–ª–µ—Ç–∫–∏, –ø–æ–º–µ—á–∞–µ–º –µ–≥–æ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π
    if (orderData.promoCode) {
      try {
        const wheelPrizesResult = await docClient.send(new ScanCommand({
          TableName: "wheelPrizes",
        }));
        
        const normalizedPromoCode = orderData.promoCode.trim().toUpperCase();
        const wheelPrize = (wheelPrizesResult.Items || []).find(p => 
          p.promoCode && p.promoCode.trim().toUpperCase() === normalizedPromoCode
        );

        if (wheelPrize && !wheelPrize.used) {
          // –ü–æ–º–µ—á–∞–µ–º –ø—Ä–∏–∑ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π
          await docClient.send(new UpdateCommand({
            TableName: "wheelPrizes",
            Key: { id: wheelPrize.id },
            UpdateExpression: "SET used = :true, usedAt = :usedAt, orderId = :orderId",
            ExpressionAttributeValues: {
              ":true": true,
              ":usedAt": new Date().toISOString(),
              ":orderId": id
            }
          }));
          console.log(`Wheel prize ${wheelPrize.id} marked as used for order ${id}`);
        }
      } catch (error) {
        console.error('Error marking wheel prize as used:', error);
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–º–µ—Ç–∏—Ç—å –ø—Ä–∏–∑
      }
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram (–Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è)
    sendTelegramNotification(order).catch(error => {
      console.error('Failed to send Telegram notification:', error);
      // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –µ—Å–ª–∏ Telegram –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    });
    
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ 
        success: true, 
        id, 
        orderId: id,
        spinsAdded: actualSpinsAdded 
      }),
    };
  } catch (error) {
    console.error("Error:", error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ error: error.message }),
    };
  }
};